
/*
  程序:斯特林公式分析程序
 
    目的:验证斯特林公式,并计算不同数值下,方程的近似程度
 
    功能:通过高精度运算计算方程结果
   
    难点:1,高精度除法的定义
         2,自然对数的高幂次(1000以上)运算
         3,N!的高精度运算(10000!左右)
  
   日期:2016年9月7日

     预计完成时间:2016年9月12日
     
     预计编程时长:未知
   
*/

//======================================================================================
//######################################################################################
//######################################################################################
//======================================================================================



# include <stdio.h>
# include <math.h>
#define CON 100000  //定义数值位数储单元存常量.10,000!为40000位左右;100,000!为500,000位左右


//************************************************************************
//=========================声明函数=======================================
//************************************************************************

 int * add(int*, int*);//声明高精度加法运算
 int * mult(int *, double);//声明高精度计算数乘法则函数(大数乘小数)
 int * dec(int *, int *);//声明高精度计算减法法则函数
 int * div(int *, int *);//声明高精度计算除法法则函数

 int * N_1(int);//声明N!计算函数(阶乘运算)
 int * N_C(int, int);//声明N^C计算函数(幂运算)
 int * e_N(int);//声明e^N计算函数
 
 void reput(int*);//定义数组清零函数
 int pot(int *, int);//声明计算数值总位数的函数
 void pri(int *, int);//声明数组数值输出函数

//*************************************************************************
//==========定义全局变量数组,以存储各函数输出结果==========================
//**************************************************************************


 int add_g[CON];
 int mult_g[CON];
 int dec_g[CON];
 int div_g[CON]; 
 int N_1_g[CON];
 int N_C_g[CON];
 int e_N_g[CON];



//***************************************************************************
//========================主函数=============================================
//***************************************************************************


 int main(void)
  {
     int n;//定义取数范围变量
     int d;//定义取数间隔变量
     int point;//定义取点个数变量
     char ch;//定义修正项取舍判断控制符
     int sig;//定义保留的有效数字变量  
  
     int left[CON];//定义Stirling公式左侧N!的存储数组,可容纳1,000,000位的数
     int right1[CON];//定义Stirling公式右侧近似值的存储数组part1,可容纳1,000,000位的数   
     int right2[CON];//定义Stirling公式右侧近似值的存储数组part2,可容纳1,000,000位的数  
     double right3;//定义Stirling公式右侧近似值的存储数组part3
     int right12[CON];//定义Stirling公式右侧近似值的存储数组part3&part2,可容纳1,000,000位的数  
     int right123[CON];//定义Stirling公式右侧近似值的存储数组总和,可容纳1,000,000位的数  
     int differ[CON];//定义Stirling公式两侧数值之差的数值存储数组,可容纳1,000,000位的数
     int pec_dif[CON];//定义Stirling公式两侧相对误差的倒数数值存储数组,可容纳1,000,000位的数

     int * cp_str;//定义数组拷贝指针
     
     printf("请输入N的范围:1<N<");
     scanf("%d", &n);
     printf("请输入数据取点个数:");
     scanf("%d", &point);
     printf("请输入要保存的有效数字:");
     scanf("%d", &sig);
     printf("方程右侧是否引入最后一项修正项?(N/Y):");
     scanf(" %c", &ch);
     printf("\n=========================================================================\n");
   
     printf("\nN                      N!                    Appro_Val                    Differ                  1/(Rela_Differ)\n\n");         //调整输入界面

     d = n / point;      //计算取点间隔

//************************************开始取点计算**************************

     for(int i=0; i<=n; i+=d)//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       {
        //========================计算数值并拷贝至主函数=================

          //-------------------方程左侧--------------------

         cp_str = N_1(i);  //初始化指针至 N! 存储数组的 头部
         
                                                          //printf("左侧赋值完毕\n");

         for (int j=0; j<CON; j++)
            {
              left[j] = *cp_str;   //单个数组元素赋值
                                                          //printf("%d", left[j]);
              cp_str++;   //指针移动
               
            }             //实现N!_数组拷贝,遍历一百万个数组元素

                                                          //printf("左侧计算完毕\n");

//printf("\n###################\n");     
//pri(left, 10);                  //N!计算数值探针
//printf("\n###################\n");  
          
          printf("%d                      ", i);
          pri(left, sig);    //sig 要保留的有效数字
          printf("                       ");


          //------------------方程右侧----------------------
         
         cp_str = N_C(i, i);//初始化指针至 N^N 存储数组的 头部
          for (int j=0; j<CON; j++)
            {
              right1[j] = *cp_str;
                                                           //printf("%d", *cp_str);
              cp_str++;
            }            //实现N^N存储数组拷贝
                                                            //printf("右侧1计算完毕\n");
//printf("\n###################\n");     
//pri(right1, 10);                   //N^N计算数值探针
//printf("\n###################\n");  
     
         cp_str = e_N(i);//初始化指针至 e^N 存储数组的 头部
          for (int j=0; j<CON; j++)
            {
              right2[j] = *cp_str;
                                                             //printf("%d", *cp_str);
              cp_str++;
            }            //实现e^N存储数组拷贝

//printf("\n###################\n");     
//pri(right2, 10);                   //exp(N)计算数值探针
//printf("\n###################\n");  
 
         
                                                              //printf("右侧2计算完毕\n");

         if('Y' == ch || 'y' == ch)          
            right3 = sqrt(2 * M_PI * i);
         else
            right3 = 1.00;                   //判断是否引入第三项修正
           
                                                              //printf("分步计算完毕\n");

//printf("\n###################\n");     
//printf("%lf", right3);                   //right3计算数值探针
//printf("\n###################\n");  

        //======================右侧的数组的合成=============================

          cp_str = div(right1, right2);//初始化指针至 p1*p2结果 存储数组 头部  
           for (int j=0; j<CON; j++)
             {
               right12[j] = *cp_str;
               cp_str++;
             }            //实现p1*p2存储数组拷贝

        
//printf("\n###################\n");     
//pri(right12, 10);                   //right12计算数值探针
//printf("\n###################\n");  
                                                                 //printf("12计算完毕\n");
          cp_str = mult(right12, right3);//初始化指针至 全部右侧结果 存储数组 头部  
          for (int j=0; j<CON; j++)
             {
               right123[j] = *cp_str;
               cp_str++;
             }            //实现p1*p2*p3存储数组拷贝
                                                                  //printf("123计算完毕\n");
   
           pri(right123, sig);
           printf("                       ");             
  
        //=======================比较两侧数值(作差)================================
           cp_str = dec(left, right123);//初始化指针至 两侧差的结果 存储数组的 头部
           for (int j=0; j<CON; j++)
             {
               differ[j] = *cp_str;
               cp_str++;
             }            //实现p1*p2*p3存储数组拷贝

           pri(differ, sig);
          printf("                       ");


                                                                    //printf("作差计算完毕\n");
        //=========================计算相对误差的倒数=============================
            cp_str = div(left, differ);
            for(int j=0; j<CON; j++)
              {
                 pec_dif[j] = *cp_str;
                 cp_str++;
              }

          pri(pec_dif, sig);
          printf("\n\n\n");   //结果输出


                                                                 //printf("误差计算完毕\n");         
        
       }  
                 
     return 0;
  }
 //==============================================================================================
 //*********************************************函数体定义***************************************
 //==============================================================================================


 //1**************************************定义高精度加法运算**********************************   
   int * add(int * a, int * b)
     {
        reput(add_g);//清零加和数组        

        int pot_a, pot_b, maxpot;

        pot_a = pot(a, CON);
        pot_b = pot(b, CON); //分别计算输入两个数的位数

        if(pot_a > pot_b)
           maxpot = pot_a;
        else
           maxpot = pot_b;  //取两数位数的最大值
 

        for (int i=0; i<maxpot; i++)
          {
              add_g[i] = (*a) + (*b);
              a++;
              b++;   
          }               //对应元素相加,直到最高位.
        
        for(int i=0; i<(maxpot+2); i++)//两个maxpot位的数字相加,最高是maxpot+1位
          {
              if(add_g[i]>9)
               {
                add_g[i+1] += add_g[i] / 10;
                add_g[i] = add_g[i] % 10; 
               }
          }             //进位处理,取maxpot+2位以确保加和空间充足(maxpot+1也可)

        return add_g;       //返回结果数组的头地址
     }
  

 //2************************************定义高精度计算乘法法则函数***************************
   int * mult(int * a, double b)
     {
        reput(mult_g);//清零数乘数组 

        int pot_a;

        pot_a = pot(a, CON);

         for (int i = 0; i < pot_a; i++)
          {
            mult_g[i] = (*a) * b;
            a++;
          }               //对每一位上对应元素值做关于b 的乘法;
     
         for (int i = 0; i < CON; i++)//不能确定b的位数,因此遍历全数组空间进行进位 
          {
             if (mult_g[i] >= 10) 
               {
                  mult_g[i + 1] += mult_g[i] / 10;
                  mult_g[i] %= 10;
                }          //完成进位
          } 
         return mult_g;        //输出结果的头地址
     }

  //3**********************************定义高精度计算减法法则函数*************************    
    int * dec(int * a, int * b)
     {
        reput(dec_g);//清零差数组       

        int pot_a, pot_b, maxpot;
          
        pot_a = pot(a, CON);
        pot_b = pot(b, CON); //计算输入两数值的位数

        if(pot_a > pot_b)
           maxpot = pot_a;
        else 
           maxpot = pot_b; //取位数的最大值
   
        for(int i=0; i<maxpot; i++)
          {
             dec_g[i] = *a - *b;
             a++;
             b++;         
          }                 //对应元素相减

  
        for(int i=0; i<(maxpot-1); i++) //借位运算只持续到第maxpot-1位,最高位不再借位
          {
             if(dec_g[i]<0)
               {
                  dec_g[i+1]--;
                  dec_g[i] += 10;
               }
          }              //完成借位运算

        return dec_g;        //返回数组头地址
     }

 //4*************************************定义高精度计算除法法则函数*************************** 
   int * div(int * a, int * b)
     {   
         reput(div_g);//清零商数组
   
         int * cp1;
         int * cp2;
         int cp_a[CON];
         int cp_b[CON];         

         cp1 = a;
         cp2 = b;
       
         for (int i=0; i<CON; i++)
           {
              cp_a[i] = *cp1;
              cp_b[i] = *cp2;
              cp1++;
              cp2++;
           }
                //拷贝除法数组        
 

        
         int de_dig;  
         int pot_a, pot_b;//定义位数变量
         int borr; //定义进位数变量

         pot_a = pot(cp_a, CON);
         pot_b = pot(cp_b, CON);  //求除数b与被除数a的位数        

                                                    //printf("%d %d \n",pot_a, pot_b);  

         while((pot_a >= pot_b)&pot_b!=0)
            {    
                                                    //printf("%d\n", cp_a[2]);        
    
               de_dig = pot_a - pot_b; //计算两个数的位差
 
               cp_a[pot_a-1] += (cp_a[pot_a]*10);  //最高位的上一位向最高位进10 
               //cp_a[pot_a] = 0;                                               
                 
                                                    //printf("\n%d\n", cp_a[pot_a]);
               
               do    
                {
                    for(int i=0; i<pot_b; i++) 
                       cp_a[de_dig+i] -= cp_b[i];  //对应位相减
    
                    for(int i=0; i<pot_b-1; i++)
                        if(cp_a[de_dig+i]<0)
                          {
                            borr =  (-(cp_a[de_dig+i]/10)+1);                       
 
                            cp_a[de_dig+i] += borr * 10;            
                            cp_a[de_dig+i+1] -= borr;                     
                          }                 //借位运算

                     div_g[de_dig]++;
              
                                                    //printf("%d\n", cp_a[pot_a-1]); 

                }while(cp_a[pot_a-1]>=0); //输出为负(多减一次)的结果 
             
                                                   //printf("bit_over\n" );

                for(int i=0; i<pot_b; i++) 
                cp_a[de_dig+i] += cp_b[i];  //对应位相加
                  
                for(int i=0; i<pot_b-1; i++)                         
                if(cp_a[de_dig+i]>9)
                  {
                    cp_a[de_dig+i+1] +=  cp_a[de_dig+i] / 10;          
                    cp_a[de_dig+i] %= 10;  
                  }                   //进位运算
                div_g[de_dig]--;  //撤回一次作差操作

 
                pot_a--;

            }
         return div_g; //输出数据头地址
     }

  
//5*************************************定义N!计算函数*************************** 
   int * N_1(int num)
     {
        reput(N_1_g);//清零阶乘数组      

        int dig, temp;
        int carry;
        
        N_1_g[0] = 1;
        dig = 1; //初始化:数字为1,只有一位.

        for (int i=2; i<=num; i++)  //从2到N进行阶乘
          {
             carry = 0;
             for(int j=1; j<=dig; j++)
               {
                  temp = N_1_g[j-1] * i + carry;
          
                  N_1_g[j-1] = temp % 10;
                  carry = temp /10;     //小于10的部分写进本位,大于的部分写入carry中
               } 
               //在旧位数上进行运算 

             while(carry) //当旧位数全部赋值完毕,而carry不为0,则创建新位
               {
                  dig++;
                  N_1_g[dig-1] = carry % 10;
                  carry /= 10;
               } 
               //数据进位完毕,进入下一个数的乘法循环
          
          }
        
        return N_1_g;

     }     

  
//6*************************************定义N^C计算函数*************************** 
  int * N_C(int cir, int num)
     {
        reput(N_C_g);//	清零幂运算数组

        int dig, temp;
        int carry;
        
        N_C_g[0] = 1;
        dig = 1;    //初始化:数值为1,位数为一.

        for (int i=1; i<=cir; i++) //控制进行乘法的次数(幂次)
          {
             carry = 0;
             for(int j=1; j<=dig; j++)
               {
                  temp = N_C_g[j-1] * num + carry; //乘法&进位运算 同步进行
          
                  N_C_g[j-1] = temp % 10;
                  carry = temp /10;
               } 
               //在旧位数上进行运算 

             while(carry)    //同阶乘的解释
               {
                  dig++;
                  N_C_g[dig-1] = carry % 10;
                  carry /= 10;
               } 
               //如果需要,则创建新位数
          
          }
        
        return N_C_g;
     }

 

//7*************************************定义e^N计算函数*************************** 
   int * e_N(int n)
     {
         reput(e_N_g);//清零exp数组
              
     //########N较小(小于700)时直接求算####################################

         if(n <= 700)
           { 
              double res;
              int i = 0;

              res = exp(n);   //直接计算出结果存入res中
                                                            //printf("%lf", res);

              while(res>=1.0)     //将res中的值写入数组
                {
                   e_N_g[i] = (int)(fmod(res, 10)); //对res取余,并强制转换位整型  

                                                           //printf("%d", (int)(fmod(res, 10))); 
                   res /= 10;
                   i++;
                }       

           }  
     //#######如果N太大(大于700),则采用Taylor展开求解##########################
         
         else
           { 
              int elem[CON]; 
              int x_n[CON];
              int n_2[CON];  
              int * tep;       //创建拷贝指针
              int j = 1;       //创建Taylor展开项数变量
 
              elem[0] = 1;    
              e_N_g[0] = 1;    //准备Taylor展开,加和初始化        

//printf("\n\n!!!!!!!\n");       
//pri(e_N_g, 6);            //初始化位置探针
//printf("\n!!!!!!!\n"); 
         
               while(pot(elem, CON)!=0)  //判断elem是否收敛至小于1,以判断是否继续加和
                { 
                    tep = N_C(j, n);
                    for(int k=0; k<CON; k++)
                       {
                          x_n[k] = *tep;
                          tep++;
                       }              //拷贝n^j数值数组

                    tep = N_1(j);
                    for(int k=0; k<CON; k++)
                       {
                          n_2[k] = *tep;
                          tep++;
                       }               //拷贝j!数值数组

                    tep = div (x_n, n_2); //计算 n^j/j! 的大小
                    for(int i=0; i<CON; i++) 
                       {  
                          elem[i] = *tep;     //将新值写入elem
                          tep++;
                       }                    //计算单个加和项(即elem)的数值

                   
//pri(elem, 5);
//printf("\n"); //收敛探针 
//printf("%d\n", j);
       
                     j++;

                     for(int i=0; i<CON; i++)
                        e_N_g[i] += elem[i];

                 }  //while结束


                for(int i=0; i<CON-1; i++)
                   {    
                       e_N_g[i+1] += e_N_g[i] / 10;
                       e_N_g[i] %= 10;     
                   }    
           }//else结束
        
        return e_N_g;
     }

 
 //8*************************************定义计算数值总位数的函数*************************** 
   int pot(int * p, int len)
     {
         int * cp_str;
         int dig;

         dig = 0;

         cp_str = p + len - 1;   //移动指针至数组尾部

         for (int j=0; j<len; j++)
            {
             if (*cp_str)        //由尾到头(由高位到低位)一次判断,
               {                               
                 dig = len - j;     //遇到非零元则退出停止循环,并记录此时位数
                 break;
               }
              cp_str--;           
            }            
      
         return dig;              //返回位数

     } 



//9*************************************定义数组数值输出函数*************************** 
   void pri(int * p, int sig)
     {
         int * cp_str;
         int poe_out;
         int pot_p;

         pot_p = pot(p, CON);
        
         if((pot_p-sig) <= 0)
           poe_out = 0;
         else
           poe_out = pot_p - sig;  //判断有效数字是否大于原数值位数
         
         if(pot_p==0)
             pot_p = 1;//防止指针溢出

         cp_str = p + (pot_p-1);  //初始化指针至 输出数组尾部
     
         for (int j=pot_p; j>poe_out; j--)
            {
              printf("%d", *cp_str);     //输出保留的有效数字
              cp_str--;   
            }             
     
         printf("E%d", poe_out);   //输出幂次

     }
  
//10*************************************定义数组归零函数*************************** 
   void reput(int * a)
     {
         for(int i=0; i<CON; i++)
           { 
              *a = 0;
               
               a++;
           }
     }         //将输入的数组归零




//======================================================================================
//######################################################################################
//######################################################################################
//======================================================================================


/*

   总结:1,指针的应用在C语言中至关重要.这次编程,由于对指正部分知识不熟悉.在函数间传指针过程中遇到很多
        困难.最后不得不放弃函数传指,改用全局变量.计算效率大大降低.今后还需要补习指针的相关知识.
        2,e^N计算中用到了Taylor展开.加和必须在elem计算之后立即进行,否则内存溢出.原因未知!
        3,除法计算的定义花费了非常多的时间,主要是因为对传指针知识的生疏,导致在计算除法函数内部,不得不重新
         定义减法,使代码趋于冗长.
    
   时间:  
        2016年6月10号 完成
        总计编程时长:22小时左右     

   运行结果:
        在Linux(Ubuntu) GCC64位编译器下,运行结果(最大值1000,取点数50, 保留6位有效数字,考虑右侧修正)
==================================================================================================
请输入N的范围:1<N<1000
请输入数据取点个数:50
请输入要保存的有效数字:6
方程右侧是否引入最后一项修正项?(N/Y):y

=========================================================================

N                      N!                    Appro_Val                    Differ                  1/(Rela_Differ)

0                      1E0                       0E0                       1E0                       1E0


20                      243290E13                       237840E13                       544970E11                       44E0


40                      815915E42                       810639E42                       527617E40                       154E0


60                      832098E76                       823361E76                       873719E74                       95E0


80                      715694E113                       711890E113                       380404E111                       188E0


100                      933262E152                       930018E152                       324316E150                       287E0


120                      668950E193                       658429E193                       105203E192                       63E0


140                      134620E236                       133864E236                       755575E233                       178E0


160                      471472E279                       463266E279                       820626E277                       57E0


180                      200896E324                       200582E324                       313846E321                       640E0


200                      788657E369                       778355E369                       103021E368                       76E0


220                      228386E416                       228198E416                       187519E413                       1217E0


240                      406788E463                       398279E463                       850859E461                       47E0


260                      383019E511                       382056E511                       963063E508                       397E0


280                      167722E560                       166785E560                       936812E557                       179E0


300                      306057E609                       305452E609                       605160E606                       505E0


320                      211610E659                       211098E659                       511888E656                       413E0


340                      510086E709                       507534E709                       255169E707                       199E0


360                      398316E760                       397667E760                       649521E757                       613E0


380                      943931E811                       934256E811                       967561E809                       97E0


400                      640345E863                       638518E863                       182630E861                       350E0


420                      117983E916                       117140E916                       842372E913                       140E0


440                      562994E968                       557086E968                       590796E966                       95E0


460                      666328E1021                       658035E1021                       829265E1019                       80E0


480                      188030E1075                       187169E1075                       861242E1072                       218E0


500                      122013E1129                       121884E1129                       128968E1126                       946E0


520                      176104E1183                       175593E1183                       510835E1180                       344E0


540                      548231E1237                       547805E1237                       425702E1234                       1287E0


560                      357794E1292                       356825E1292                       968767E1289                       369E0


580                      476763E1347                       476024E1347                       739173E1344                       644E0


600                      126557E1403                       125736E1403                       820821E1400                       154E0


620                      654052E1458                       649743E1458                       430914E1456                       151E0


640                      644097E1514                       639838E1514                       425831E1512                       151E0


660                      118455E1571                       118024E1571                       431106E1568                       274E0


680                      399218E1627                       398943E1627                       274871E1624                       1452E0


700                      242204E1684                       241119E1684                       108415E1682                       223E0


720                      260121E1741                       259297E1741                       823897E1738                       315E0


740                      486755E1798                       486362E1798                       393163E1795                       1238E0


760                      156339E1856                       156089E1856                       250082E1853                       625E0


780                      849723E1913                       849556E1913                       167454E1910                       5074E0


800                      771053E1971                       761969E1971                       908391E1969                       84E0


820                      115325E2030                       114466E2030                       858747E2027                       134E0


840                      280871E2088                       279868E2088                       100327E2086                       279E0


860                      110101E2147                       109572E2147                       529304E2144                       208E0


880                      687036E2205                       686670E2205                       365930E2202                       1877E0


900                      675268E2264                       674531E2264                       736867E2261                       916E0


920                      103490E2324                       103440E2324                       499333E2320                       2072E0


940                      244941E2383                       244270E2383                       670512E2380                       365E0


960                      887042E2442                       879580E2442                       746182E2440                       118E0


980                      487193E2502                       486238E2502                       955479E2499                       509E0


1000                      402387E2562                       402011E2562                       375294E2559                       1072E0







   ================================================================================================ 

     计算完成耗时:46min
        

   参考部分:

        阶乘(N_1)和大数幂运算(N_C)部分是在网络上参考相关资源后编成
 

*/

